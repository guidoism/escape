### Motivation

I want to be able to experiment with different computer architectures. Any changes I make between architectures should be clear and succinct.

### Assumptions

-  I will be able to get most of the way when describing memory and logic gate layouts and manipulations with APL's notation, especially the later formalizations â€” More's [*Axioms and Theorems for a Theory of Arrays*](http://gifi.stat.ucla.edu/apl/literature/arrays/more_73.pdf) and its realization into [APL2](https://public.dhe.ibm.com/common/ssi/ecm/zs/en/zsb03142usen/systems-hardware-z-systems-zs-redbook-zsb03142usen-20180425.pdf).

- I should take advantage of [APL's boxed display](https://aplwiki.com/LearnMoreApl/Display) of an array to understand manipulations.

- Hill and Peterson's *Digital Systems: Hardware Organiztion and Design* is a great way to understand how to formally description the architecture of computers with APL, specifically AHPL.

- I can learn APL by implmenting it in terms of other languages. Python is good because I know it best and itertools is awesome and Javascript is good because I can use it on a no-install simulator. Javascript's typed arrays are of particular interest to me for learning how to represent the arrays as a stream of bits.

- Eli Bendersky's *[Memory layout of multi-dimensional arrays](https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays/)* is a good start for my lower level implementations.




